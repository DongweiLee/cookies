// This autogenerated skeleton file illustrates one way to adapt a synchronous
// interface into an asynchronous interface. You should copy it to another
// filename to avoid overwriting it and rewrite as asynchronous any functions
// that would otherwise introduce unwanted latency.

#include <string>
#include "boost/shared_ptr.hpp"
#include <thrift/Thrift.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TSocket.h>
#include <thrift/transport/TTransportUtils.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/server/TServer.h>
#include <thrift/async/TAsyncChannel.h>
#include <thrift/async/TEvhttpClientChannel.h>
#include <thrift/async/TAsyncProtocolProcessor.h>
#include <thrift/async/TEvhttpServer.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include "Test.h"


using namespace apache::thrift;
using namespace apache::thrift::protocol;
using namespace apache::thrift::transport;
using std::string;
using namespace boost;
using namespace apache::thrift::async;
using namespace ::apache::thrift::async;
using boost::shared_ptr;
using namespace  ::uctest;

class TestAsyncHandler : public TestCobSvIf {
	public:
		TestAsyncHandler(){
/*			string line;
			for (int i = 33; i < 127; ++i)
			{
				line.push_back(char(i));
			}
			line += line;

			for (size_t i = 0; i < 127-33; ++i)
			{
				_response += line.substr(i, 72) + '\n';
			}*/
		}
		void pingpong(tcxx::function<void(std::string const& _return)> cob, const std::string& data) {
			std::string _return;
			_return="pong";
//			_return=_response;
			return cob(_return);
		}
		std::string _response;

};

int main(int argc, char **argv) {
	shared_ptr<TAsyncProcessor> underlying_pro(new TestAsyncProcessor( shared_ptr<TestCobSvIf>(new TestAsyncHandler()) ) );
	shared_ptr<TAsyncBufferProcessor> processor( new TAsyncProtocolProcessor( underlying_pro, shared_ptr<TProtocolFactory>(new TBinaryProtocolFactory()) ) );

	TEvhttpServer server(processor, 9093);
	server.serve();
	return 0;
}
